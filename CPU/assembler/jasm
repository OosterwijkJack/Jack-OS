#!/usr/bin/python

# In the future the assembler will be written in my assembly language then transformed 
# into machine language that runs on my simulated cpu via this program. Then it will 
# be able to run in my operating systemâ€™s environment 
# cp /home/jack/Desktop/Jack-OS/CPU/assembler/jasm /home/jack/.local/bin

import sys

ARG1_SIZE = 2**21

func_table = {
    "add": 0,
    "sub": 1,
    "mul": 2,
    "div": 3,
    "mov": 4,
    "and": 5,
    "or": 6,
    "xor": 7,
    "not": 8,
    "compb": 9,
    "compl": 10,
    "jeq": 11,
    "jlt": 12,
    "jgt": 13,
    "jne": 14,
    "jmp": 15,
    "load": 16,
    "save": 17,
    "push": 18,
    "pop": 19,
    "int": 20}

reg_names = {
    "r0": 1,
    "r1": 2,
    "r2": 3,
    "r3": 4,
    "r4": 5,
    "r5": 6,
    "r6": 7,
    "r7": 8,
    "r8": 9,
    "r9": 10,
    "rpc": 11,
    "rsp": 12,
    "rsb": 13,
    "rcf": 14,
    "rfg": 15,
    "ra1": 16,
    "ra2": 17,
    "rek": 18,
    "rjo": 19,
}

constants = {
    "STDIN": 1
}

label_dict = {}

def main ():

    if(len(sys.argv) < 3 or len(sys.argv) > 3):
        print("Usage: python3 assembler.py {file} {out}")
        exit(1)

    assembled = ''
    
    convert_labels() # converts labels to numbers
    assemble_no_labels() # assembles

    #open(sys.argv[2], 'w').write(assembled)

def assemble_no_labels():
    f = open(sys.argv[2], 'r')
    bits = []

    for a,i in enumerate(f.readlines()):

        for e in constants.keys():
            if(e in i):
                i = i.replace(e, str(constants[e]))


        if(len(i) <= 1):
            continue

        if i.startswith("//"):
            continue

        curstr = ""

        space = i.find(" ")

        instruction = i[0:space]

        try:
            curstr += str(bin(func_table[instruction]))[2:].zfill(5) # convert instruction to binary of 5 bits
        except KeyError:
            print(f"Invalid instruction '{instruction}'")
            exit(1)
        except Exception as e:
            print(e)
            exit(1)

        comma = i.find(",")

        arg1 = i[space+1:comma]
        
        if(arg1 in reg_names.keys()):
            curstr += '0'
            try:
                curstr += str(bin(reg_names[arg1])[2:].zfill(21))
            except KeyError:
                print(f"Invalid register '{arg1}'")
                exit(1)
            except Exception as e:
                print(e)
                exit(1)
        else:   
            if(int(arg1) > ARG1_SIZE):
                print(f"Arg1 number exceeds limit of {ARG1_SIZE} on line {a+1}")
                exit(1)
            curstr += '1'
            curstr += str(bin(int(arg1)))[2:].zfill(21)
        
        if(comma != -1):
            arg2 = i[comma+1: len(i.rstrip())]
            try:
                curstr += str(bin(reg_names[arg2]))[2:].zfill(5)
            except KeyError:
                print(f"Invalid register '{arg2}'")
                exit(1)
            except Exception as e:
                print(e)
                exit(1)
        else:
            curstr += "0"*5

        bits.append(curstr)
    f.close()

    f = open(sys.argv[2],'w')

    # split 4 byte operation into 1 byte
    for bit_str in (bits):
        bytes_data = []
        for i in range(0,len(bit_str),8):
            bytes_data.append(bit_str[i:i+8])

            #  reverse order        
        bytes_data.reverse()

        for i in bytes_data:
            f.write(i + "\n")

    f.close()
        


def convert_labels():
    lines = []
    with open(sys.argv[1], 'r') as f:
        for i in f.readlines():
            lines.append(i)
        f.close()

    # add labels to label dict and remove them from lines list
    line_count = 0
    lines_new = []
    for j in lines:
        j = str(j)
        j = j.strip()

        if(j.strip() == ''): # ignore white space
            continue

        if(j.startswith)("//"):
            continue

        tmp = j.find("//")
        if(tmp != -1):
            j = j[0:tmp]

        if(j.endswith(":")):
            label = j[0:-1] 
            if label in label_dict.keys(): # check if label has already been defined
                print(f"Two definitions of label {label}")
                exit(1)
            else:
                label_dict[label] = line_count
        else:
            lines_new.append(j) # if not a label add to new line list and increment line count
            line_count+=1

    file = open(sys.argv[2], 'w')
    for i in lines_new:        
        if(len(label_dict) <= 0):
            file.write(i + "\n")
            continue

        for j in label_dict.keys():

            if j in i:
                file.write(i.replace(j, str(label_dict[j])) + "\n")
            else: 
                file.write(i + "\n")
    file.close()

        


if __name__ == "__main__":
    main()